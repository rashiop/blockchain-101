# Making the zombie factory

## Code
```sol

pragma solidity >=0.5.0 <0.6.0;

contract ZombieFactory {

    event NewZombie(uint zombieId, string name, uint dna);

    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits;

    struct Zombie {
        string name;
        uint dna;
    }

    Zombie[] public zombies;

    function _createZombie(string memory _name, uint _dna) private {
        uint id = zombies.push(Zombie(_name, _dna)) - 1;
        emit NewZombie(id, _name, _dna);
    }

    function _generateRandomDna(string memory _str) private view returns (uint) {
        uint rand = uint(keccak256(abi.encodePacked(_str)));
        return rand % dnaModulus;
    }

    function createRandomZombie(string memory _name) public {
        uint randDna = _generateRandomDna(_name);
        _createZombie(_name, randDna);
    }

}

```

## Contracts
All solidity's code encapsulated in `contracts` - all variables & function.

### Version pragma
Declare solidity compiler version of the code, to prevent breaking change.

### State Variables and integer
`State var` permanently stored in contract storage
- written to the ETH blockchain -- like DB

`uint`
- unsigned integer
- non-negative
- alias for uint256
- alt uint6, uint16, uint32, etc
- just declare uint

### Math operation
- add +
- substract - 
- multiplication *
- division /
- modulus %
- exponential **

### Structs
More complicated data types
```sol
struct Zombie {
  string name;
  <<dataType>> <<name>>;
}
```

### Arrays
Array based on length.
Array can use `structs` as dataType
- fixed
```sol
uint[2] fixedArray
```
- dynamic
```sol
uint[] dynamicArray
Zombie[] zombies
```
Public Array
- SOL automatically create a getter method for it 
- Readonly from other contracts
```sol
Zombie[] public zombies
```

### Function
Argument
- arg startsWith `_` to diffrentiate it from global var
- passing
  - by value
  - by reference
- memory - stored it in memory
  - required for `reference` type `array, structs, mappings, strings`
```sol
function createZombie(string memory _name, uint _dna) public{

}
```
Return
```sol
string greeting = "SUP"
function sayHello() public returns (string memory) {
  return greeting;
}
```
View only, wont modify contract's variable
```sol
function sayHello() public view returns (string memory) {}
```
Pure - dont access any data on app
```sol
function _multiply(uint a, uint b) private pure returns (uint) {
  return a * b;
}

```

### Keccak256 [insecure]
ETH built-in hash function `keccak256` - version of SHA3, which has input into random 256 
```sol
//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5
keccak256(abi.encodePacked("aaaab"));
//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9
keccak256(abi.encodePacked("aaaac"));
```

### Typecasting
dataType var = dataType(b)

### Events
Events are a way for our contract to communicate something that happened on the blockchain to your front-end app (pub-sub), which can be 'listening' for certain events and take action when they happen

Blockchain
```sol
// declare the event
event IntegersAdded(uint x, uint y, uint result);

function add(uint _x, uint _y) public returns (uint) {
  uint result = _x + _y;
  // fire an event to let the app know the function was called:
  emit IntegersAdded(_x, _y, result);
  return result;
}
```

FE JS
```js
YourContract.IntegersAdded(function(error, result) {
  // do something with result
})
```


### Javascript frontend
ETH has JS lib called `Web3.js`
```js
// Here's how we would access our contract:
var abi = /* abi generated by the compiler */
var ZombieFactoryContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// `ZombieFactory` has access to our contract's public functions and events

// some sort of event listener to take the text input:
$("#ourButton").click(function(e) {
  var name = $("#nameInput").val()
  // Call our contract's `createRandomZombie` function:
  ZombieFactory.createRandomZombie(name)
})

// Listen for the `NewZombie` event, and update the UI
var event = ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  generateZombie(result.zombieId, result.name, result.dna)
})

// take the Zombie dna, and update our image
function generateZombie(id, name, dna) {
  let dnaStr = String(dna)
  // pad DNA with leading zeroes if it's less than 16 characters
  while (dnaStr.length < 16)
    dnaStr = "0" + dnaStr

  let zombieDetails = {
    // first 2 digits make up the head. We have 7 possible heads, so % 7
    // to get a number 0 - 6, then add 1 to make it 1 - 7. Then we have 7
    // image files named "head1.png" through "head7.png" we load based on
    // this number:
    headChoice: dnaStr.substring(0, 2) % 7 + 1,
    // 2nd 2 digits make up the eyes, 11 variations:
    eyeChoice: dnaStr.substring(2, 4) % 11 + 1,
    // 6 variations of shirts:
    shirtChoice: dnaStr.substring(4, 6) % 6 + 1,
    // last 6 digits control color. Updated using CSS filter: hue-rotate
    // which has 360 degrees:
    skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360),
    eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360),
    clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360),
    zombieName: name,
    zombieDescription: "A Level 1 CryptoZombie",
  }
  return zombieDetails
}

```

### Result
![Screenshot 2022-09-01 at 15 27 40](https://user-images.githubusercontent.com/31156788/187868818-6991d3d2-132a-44bf-99e8-2a8aa58a47e4.png)
